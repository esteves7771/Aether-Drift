<!DOCTYPE aether>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aether Drift</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        :root {
            --bg-color: #0d0a1b;
            --main-color: #42e6a9;
            --accent-color: #e642e6;
            --ui-bg: rgba(66, 230, 169, 0.1);
        }

        body {
            background-color: var(--bg-color);
            color: var(--main-color);
            font-family: 'Orbitron', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* Landscape Mode Message */
        .orientation-message {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: var(--main-color);
            font-size: 1.5rem;
            text-align: center;
            flex-direction: column;
            justify-content: center;
            z-index: 100;
        }

        @media screen and (orientation: portrait) {
            .orientation-message {
                display: flex;
            }
            .game-container {
                display: none;
            }
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        canvas {
            background-color: transparent;
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none; /* Prevents default touch actions like scrolling */
        }

        .ui-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 2rem;
            background-color: var(--ui-bg);
            border: 2px solid var(--main-color);
            border-radius: 15px;
            box-shadow: 0 0 20px var(--main-color);
            animation: fadeIn 0.5s ease-in-out forwards;
            max-width: 90%;
        }

        /* Fade-out animation for screen transitions */
        .fade-out {
            animation: fadeOut 0.5s ease-in-out forwards;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        h1 {
            font-size: clamp(1.5rem, 5vw, 3rem);
            margin-bottom: 1rem;
            text-shadow: 0 0 10px var(--main-color);
        }

        p {
            font-size: clamp(0.8rem, 2vw, 1.2rem);
            line-height: 1.5;
            margin: 0.5rem 0;
        }

        .btn-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .btn {
            background: linear-gradient(45deg, var(--main-color), #399c75);
            color: var(--bg-color);
            border: none;
            padding: 0.75rem 1.5rem;
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: bold;
            text-transform: uppercase;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(66, 230, 169, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(66, 230, 169, 0.6);
        }

        #score-display {
            position: absolute;
            top: 1rem;
            left: 1rem;
            font-size: clamp(1rem, 3vw, 2rem);
            text-shadow: 0 0 8px var(--main-color);
            display: none;
        }
        
        #fullscreen-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            z-index: 20;
            padding: 5px;
            font-size: 24px;
            text-shadow: 0 0 5px #fff;
            display: none;
        }

        #high-score-display {
            font-size: clamp(1rem, 2.5vw, 1.5rem);
            text-shadow: 0 0 8px var(--accent-color);
            margin-top: 0.5rem;
        }
        #fullscreen-btn {
            background: #252441;
            color: #ccc;
        }
        #gyro-btn {
            background: #252441;
            color: #ccc;
        }

        #music-btn, #sfx-btn {
            background: linear-gradient(45deg, var(--accent-color), #a842e6);
            box-shadow: 0 5px 15px rgba(230, 66, 230, 0.4);
        }
        #music-btn:hover, #sfx-btn:hover {
            box-shadow: 0 8px 20px rgba(230, 66, 230, 0.6);
        }

        /* Hide elements initially */
        #game-screen, #settings-screen, #how-to-play-screen, #game-over-screen {
            display: none;
        }
        
        /* Boss Health Bar */
        #boss-health-container {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 500px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 15px #ff0000;
            display: none;
        }
        
        #boss-health-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6666);
            transition: width 0.3s ease-in-out;
        }
        
        /* Player Health Bar */
        #player-health-container {
            position: absolute;
            top: 4rem;
            left: 1rem;
            width: 120px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #42e6a9;
            box-shadow: 0 0 10px #42e6a9;
            display: none;
        }
        
        #player-health-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #42e6a9, #a842e6);
            transition: width 0.3s ease-in-out;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.58/build/Tone.min.js"></script>
</head>
<body>
    <div class="orientation-message">
        <h1>Please Rotate Your Device</h1>
        <p>This game is best played in landscape mode.</p>
    </div>

    <div class="game-container">
        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>
        <!-- A placeholder div for the game screen, controlled by JS -->
        <div id="game-screen"></div>

        <!-- UI Screens -->
        <div id="main-menu-screen" class="ui-screen">
            <h1>Aether Drift</h1>
            <p id="high-score-display">High Score: 0</p>
            <div class="btn-container">
                <button id="start-btn" class="btn">Start Game</button>
                <button id="how-to-play-btn" class="btn">How to Play</button>
                <button id="settings-btn" class="btn">Settings</button>
            </div>
        </div>
        
        <div id="settings-screen" class="ui-screen">
            <h1>Settings</h1>
            <div class="btn-container">
                <button id="music-btn" class="btn">Music: On</button>
                <button id="sfx-btn" class="btn">SFX: On</button>
                <button id="back-btn" class="btn">Back</button>
            </div>
        </div>
        
        <div id="how-to-play-screen" class="ui-screen">
            <h1>How to Play</h1>
            <p><strong>Player Controls:</strong></p>
            <ul>
                <li>Tap and drag anywhere on the screen to move.</li>
                <li>Use the arrow keys on your keyboard to move.</li>
                <li>Tap or click to fire projectiles at enemies.</li>
            </ul>
            <p><strong>Game Objective:</strong></p>
            <ul>
                <li>Destroy enemies to increase your score.</li>
                <li>Avoid enemy projectiles.</li>
                <li>Defeat the boss to progress to the next difficulty level.</li>
            </ul>
            <button id="how-to-play-back-btn" class="btn">Back</button>
        </div>

        <div id="game-over-screen" class="ui-screen">
            <h1>Game Over</h1>
            <p>Your final score:</p>
            <p id="final-score">0</p>
            <p id="game-over-high-score">High Score: 0</p>
            <div class="btn-container">
                <button id="play-again-btn" class="btn">Play Again</button>
                <button id="main-menu-btn" class="btn">Main Menu</button>
            </div>
        </div>
        
        <div id="boss-health-container">
            <div id="boss-health-bar"></div>
        </div>
        
        <div id="player-health-container">
            <div id="player-health-bar"></div>
        </div>

        <!-- Score Display -->
        <div id="score-display">Score: 0</div>
    </div>

    <script>
        // Use Tone.js for music and sound effects
        const mainMusic = new Tone.Player("https://cdn.jsdelivr.net/gh/esteves7771/Aether-Drift/neon-gaming-128925.mp3").toDestination();
        mainMusic.loop = true;
        mainMusic.autostart = false;
        const bossMusic = new Tone.Player("https://cdn.jsdelivr.net/gh/esteves7771/Aether-Drift/the-final-boss-battle-158700.mp3").toDestination();
        bossMusic.loop = true;
        bossMusic.autostart = false;
        
        const fireSynth = new Tone.Synth({
            oscillator: { type: "square" },
            envelope: { attack: 0.001, decay: 0.1, sustain: 0.05, release: 0.1 }
        }).toDestination();
        fireSynth.volume.value = -12; // Adjusted volume
        
        const enemyExplosionSynth = new Tone.NoiseSynth().toDestination();
        const playerExplosionSynth = new Tone.MembraneSynth().toDestination();
        const enemyFireSynth = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: { attack: 0.001, decay: 0.1, sustain: 0.05, release: 0.1 }
        }).toDestination();
        const bossFireSynth = new Tone.Synth({
            oscillator: { type: "sawtooth" },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 }
        }).toDestination();
        const shardSynth = new Tone.Synth().toDestination();
        const powerupSynth = new Tone.Synth().toDestination();
        const shieldSynth = new Tone.MetalSynth({
            frequency: 200,
            envelope: { attack: 0.001, decay: 0.2, release: 0.1 },
            harmonicity: 5.1,
            modulationIndex: 32,
            resonance: 400,
            octaves: 1.5
        }).toDestination();
        const alienSound = new Tone.NoiseSynth({
            noise: { type: 'pink' },
            envelope: { attack: 0.1, decay: 0.4, sustain: 0, release: 0.5 }
        }).toDestination();
        const tripleShotSynth = new Tone.Synth({
            oscillator: { type: "sawtooth" },
            envelope: { attack: 0.001, decay: 0.2, sustain: 0.1, release: 0.2 }
        }).toDestination();

        let musicEnabled = true;
        let sfxEnabled = true;

        function playMusic() {
            if (musicEnabled) {
                mainMusic.volume.value = -12;
                mainMusic.start().fadeIn = 2;
                bossMusic.stop();
            }
        }

        function stopMusic() {
            mainMusic.stop();
            bossMusic.stop();
        }

        function playFireSound() {
            if (sfxEnabled) {
                fireSynth.triggerAttackRelease("C4", "16n");
            }
        }
        
        let lastExplosionSoundTime = 0;
        const explosionSoundCooldown = 50;
        function playEnemyExplosionSound() {
            if (sfxEnabled && performance.now() - lastExplosionSoundTime > explosionSoundCooldown) {
                enemyExplosionSynth.triggerAttackRelease("16n", Tone.now());
                lastExplosionSoundTime = performance.now();
            }
        }

        function playPlayerExplosionSound() {
            if (sfxEnabled) {
                playerExplosionSynth.triggerAttackRelease();
            }
        }
        
        function playEnemyFireSound() {
            if (sfxEnabled) {
                enemyFireSynth.triggerAttackRelease("A3", "16n", Tone.now());
            }
        }
        
        function playBossFireSound() {
            if (sfxEnabled) {
                bossFireSynth.triggerAttackRelease("C2", "8n", Tone.now());
            }
        }

        function playShardSound() {
            if (sfxEnabled) {
                shardSynth.triggerAttackRelease("C5", "32n");
            }
        }

        function playShieldSound() {
            if (sfxEnabled) {
                shieldSynth.triggerAttackRelease();
            }
        }
        
        function playTripleShotSound() {
            if (sfxEnabled) {
                tripleShotSynth.triggerAttackRelease("F4", "8n");
            }
        }

        function playAlienSound() {
            if (sfxEnabled) {
                alienSound.triggerAttackRelease('1s', Tone.now());
            }
        }
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const screens = {
            mainMenu: document.getElementById('main-menu-screen'),
            settings: document.getElementById('settings-screen'),
            howToPlay: document.getElementById('how-to-play-screen'),
            game: document.getElementById('game-screen'),
            gameOver: document.getElementById('game-over-screen')
        };
        const scoreDisplay = document.getElementById('score-display');
        const finalScoreDisplay = document.getElementById('final-score');
        const gameOverHighScoreDisplay = document.getElementById('game-over-high-score');
        const musicBtn = document.getElementById('music-btn');
        const sfxBtn = document.getElementById('sfx-btn');
        const highScoreDisplay = document.getElementById('high-score-display');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const gyroBtn = document = ('gyro-btn');
        const bossHealthContainer = document.getElementById('boss-health-container');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const playerHealthContainer = document.getElementById('player-health-container');
        const playerHealthBar = document.getElementById('player-health-bar');
        
        let gameRunning = false;
        let score = 0;
        let player, enemies, bullets, enemyBullets, powerups, explosions;
        let lastTimestamp = 0;
        let gameSpeed = 100;
        let enemySpawnInterval = 2000;
        let lastEnemySpawnTime = 0;
        let stars = [];
        let parallaxStars = [];
        let nextBossThreshold = 3000;
        let enemyBulletSpeed = 3;
        let powerupSpawnInterval = 10000;
        let lastPowerupSpawnTime = 0;
        let lastFireTime = 0;
        const fireRate = 100; 
        let difficultyLevel = 1;
        let boss;
        let gameMode = 'normal';
        let bossAttackCooldown = 1500;
        let lastBossAttackTime = 0;
        let backgroundHue = 200;
        const hueShiftSpeed = 0.5;
        let baseEnemyHealth = 3;

        // Player health
        const PLAYER_MAX_HEALTH = 3;
        let playerHealth = PLAYER_MAX_HEALTH;

        // Power-up state
        let shieldActive = false;
        let shieldTimer = 0;
        let magnetActive = false;
        let magnetTimer = 0;
        const SHIELD_DURATION = 5000;
        const DOUBLE_SHOT_DURATION = 5000;
        let doubleShotActive = false;
        let doubleShotTimer = 0;
        const TRIPLE_SHOT_DURATION = 5000;
        let tripleShotActive = false;
        let tripleShotTimer = 0;
        
        // Player properties
        const playerSize = 10;
        const playerColor = '#42e6a9';
        let keyboardMovement = { x: 0, y: 0 };
        let isFiring = false;
        let isDragging = false;
        let touchStartPos = { x: 0, y: 0 };
        let hasGyro = false;
        let isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // High score
        let highScore = 0;
        
        // --- Game Classes ---
        class Boss {
            constructor() {
                this.x = canvas.width / 2;
                this.y = -200;
                this.targetY = 150;
                this.size = 100;
                this.health = Math.round(100 * Math.pow(1.1, difficultyLevel - 1));
                this.maxHealth = this.health;
                this.isAttacking = false;
                this.attackPattern = Math.floor(Math.random() * 3);
                this.lastAttackTime = 0;
                this.attackInterval = Math.max(1000, 2000 - difficultyLevel * 100);
                this.bulletSpeed = 2 + difficultyLevel * 0.5;
                this.movementDirection = Math.random() > 0.5 ? 1 : -1;
                this.movementSpeed = 1;
            }

            draw() {
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                
                // Main body (diamond shape)
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - 70);
                ctx.lineTo(this.x - 70, this.y + 30);
                ctx.lineTo(this.x, this.y + 130);
                ctx.lineTo(this.x + 70, this.y + 30);
                ctx.closePath();
                ctx.fill();

                // Left wing
                ctx.fillStyle = '#ff6666';
                ctx.beginPath();
                ctx.moveTo(this.x - 70, this.y + 30);
                ctx.lineTo(this.x - 120, this.y + 80);
                ctx.lineTo(this.x - 70, this.y + 80);
                ctx.closePath();
                ctx.fill();

                // Right wing
                ctx.beginPath();
                ctx.moveTo(this.x + 70, this.y + 30);
                ctx.lineTo(this.x + 120, this.y + 80);
                ctx.lineTo(this.x + 70, this.y + 80);
                ctx.closePath();
                ctx.fill();
                
                // Central core
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.arc(this.x, this.y + 10, 20, 0, Math.PI * 2);
                ctx.fill();

                // Weapon pods
                ctx.shadowColor = 'rgba(0, 255, 255, 0.8)';
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(this.x - 85, this.y + 85, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x + 85, this.y + 85, 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
            }

            update() {
                // Move boss to target position
                if (this.y < this.targetY) {
                    this.y += 1;
                } else {
                    // Oscillate horizontally
                    this.x += this.movementDirection * this.movementSpeed;
                    if (this.x < 100 || this.x > canvas.width - 100) {
                        this.movementDirection *= -1;
                    }
                }
                
                // Attack logic
                if (performance.now() - this.lastAttackTime > this.attackInterval) {
                    this.attack();
                    this.lastAttackTime = performance.now();
                }
            }

            attack() {
                playBossFireSound();
                this.attackPattern = Math.floor(Math.random() * 3);
                
                if (this.attackPattern === 0) { // Spread Shot
                    const numBullets = 3 + difficultyLevel;
                    for (let i = 0; i < numBullets; i++) {
                        const angle = (i / (numBullets - 1)) * Math.PI - Math.PI/2;
                        enemyBullets.push({
                            x: this.x,
                            y: this.y + this.size,
                            size: 10,
                            speedY: this.bulletSpeed * Math.sin(angle),
                            speedX: this.bulletSpeed * Math.cos(angle),
                            isHoming: false
                        });
                    }
                } else if (this.attackPattern === 1) { // Homing Shot
                     enemyBullets.push({
                        x: this.x,
                        y: this.y + this.size,
                        size: 10,
                        speedY: this.bulletSpeed,
                        speedX: 0,
                        isHoming: true,
                        homingStartTime: performance.now(),
                        homingDuration: 1500
                     });
                } else if (this.attackPattern === 2) { // Burst Fire
                     const numBullets = 2 + difficultyLevel;
                     for (let i = 0; i < numBullets; i++) {
                        setTimeout(() => {
                           enemyBullets.push({
                                x: this.x,
                                y: this.y + this.size,
                                size: 10,
                                speedY: this.bulletSpeed,
                                speedX: 0,
                                isHoming: false
                            });
                        }, i * 200);
                     }
                }
            }
        }
        
        // --- Event Listeners for UI ---
        document.getElementById('start-btn').addEventListener('click', async () => {
            // Start the audio context first, tied to a user gesture
            await Tone.start();
            if (isMobile) {
                requestFullScreen();
            }
            startGame();
        });
        document.getElementById('play-again-btn').addEventListener('click', startGame);
        document.getElementById('how-to-play-btn').addEventListener('click', () => showScreen(screens.howToPlay));
        document.getElementById('settings-btn').addEventListener('click', () => showScreen(screens.settings));
        document.getElementById('back-btn').addEventListener('click', () => showScreen(screens.mainMenu));
        document.getElementById('how-to-play-back-btn').addEventListener('click', () => showScreen(screens.mainMenu));
        document.getElementById('main-menu-btn').addEventListener('click', () => {
            stopMusic();
            showScreen(screens.mainMenu);
        });

        // Toggle music and SFX
        musicBtn.addEventListener('click', () => {
            musicEnabled = !musicEnabled;
            musicBtn.textContent = `Music: ${musicEnabled ? 'On' : 'Off'}`;
            if (musicEnabled) {
                if (gameRunning) {
                    if (gameMode === 'normal') {
                        playMusic();
                    } else {
                        playBossMusic();
                    }
                } else {
                    mainMusic.start();
                    mainMusic.volume.value = -12;
                }
            } else {
                stopMusic();
            }
        });
        sfxBtn.addEventListener('click', () => {
            sfxEnabled = !sfxEnabled;
            sfxBtn.textContent = `SFX: ${sfxEnabled ? 'On' : 'Off'}`;
        });
        
        function requestFullScreen() {
            const element = document.documentElement;
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) { // Firefox
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) { // Chrome, Safari and Opera
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) { // IE/Edge
                element.msRequestFullscreen();
            }
        }
        
        document.addEventListener('fullscreenchange', (event) => {
            if (document.fullscreenElement) {
                // In full screen mode
                if (window.innerWidth > window.innerHeight) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                } else {
                    canvas.width = window.innerHeight;
                    canvas.height = window.innerWidth;
                }
            } else {
                // Exiting full screen
                resizeCanvas();
            }
        });

        // Keyboard event listeners
        window.addEventListener('keydown', (e) => {
            if (gameRunning) {
                if (e.key === 'ArrowLeft') {
                    keyboardMovement.x = -1;
                } else if (e.key === 'ArrowRight') {
                    keyboardMovement.x = 1;
                } else if (e.key === 'ArrowUp') {
                    keyboardMovement.y = -1;
                } else if (e.key === 'ArrowDown') {
                    keyboardMovement.y = 1;
                } else if (e.key === ' ' || e.key === 'Spacebar') {
                    isFiring = true;
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (gameRunning) {
                if (e.key === 'ArrowLeft') {
                    keyboardMovement.x = 0;
                } else if (e.key === 'ArrowRight') {
                    keyboardMovement.x = 0;
                } else if (e.key === 'ArrowUp') {
                    keyboardMovement.y = 0;
                } else if (e.key === 'ArrowDown') {
                    keyboardMovement.y = 0;
                } else if (e.key === ' ' || e.key === 'Spacebar') {
                    isFiring = false;
                }
            }
        });

        // Mouse/touch event listeners for firing
        canvas.addEventListener('mousedown', (e) => {
            if (!isMobile) {
                isFiring = true;
            }
        });
        canvas.addEventListener('mouseup', () => {
            if (!isMobile) {
                isFiring = false;
            }
        });

        // Touch movement and firing logic for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            isDragging = true;
            touchStartPos.x = touch.clientX;
            touchStartPos.y = touch.clientY;
            isFiring = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging) {
                const touch = e.touches[0];
                const dx = touch.clientX - touchStartPos.x;
                const dy = touch.clientY - touchStartPos.y;
                player.x += dx;
                player.y += dy;
                touchStartPos.x = touch.clientX;
                touchStartPos.y = touch.clientY;
            }
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
            isFiring = false;
        });

        // Screen management function with transitions
        function showScreen(screenToShow) {
            const currentScreen = Object.values(screens).find(screen => screen.style.display === 'block');
            
            if (currentScreen) {
                currentScreen.classList.add('fade-out');
                currentScreen.addEventListener('animationend', function handler() {
                    currentScreen.classList.remove('fade-out');
                    currentScreen.style.display = 'none';
                    if (screenToShow) {
                        screenToShow.style.display = 'block';
                        screenToShow.classList.remove('fade-out');
                    }
                    if (screenToShow === screens.game) {
                        scoreDisplay.style.display = 'block';
                        bossHealthContainer.style.display = 'none';
                        playerHealthContainer.style.display = 'block';
                    } else {
                        scoreDisplay.style.display = 'none';
                        bossHealthContainer.style.display = 'none';
                        playerHealthContainer.style.display = 'none';
                    }
                    currentScreen.removeEventListener('animationend', handler);
                });
            } else {
                 if (screenToShow) {
                    screenToShow.style.display = 'block';
                    if (screenToShow === screens.game) {
                        scoreDisplay.style.display = 'block';
                        bossHealthContainer.style.display = 'none';
                        playerHealthContainer.style.display = 'block';
                    } else {
                        scoreDisplay.style.display = 'none';
                        bossHealthContainer.style.display = 'none';
                        playerHealthContainer.style.display = 'none';
                    }
                }
            }
        }
        
        // High score functions
        function saveHighScore() {
            if (score > highScore) {
                highScore = Math.floor(score);
                localStorage.setItem('aetherDriftHighScore', highScore);
            }
        }

        function loadHighScore() {
            const storedScore = localStorage.getItem('aetherDriftHighScore');
            if (storedScore) {
                highScore = parseInt(storedScore, 10);
            }
            highScoreDisplay.textContent = `High Score: ${highScore}`;
            gameOverHighScoreDisplay.textContent = `High Score: ${highScore}`;
        }

        function init() {
            loadHighScore();
            showScreen(screens.mainMenu);
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    opacity: Math.random() * 0.8 + 0.2
                });
            }
            for (let i = 0; i < 100; i++) {
                parallaxStars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 1.5 + 0.3,
                    opacity: Math.random() * 0.5 + 0.1
                });
            }

            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            gameRunning = true;
            score = 0;
            playerHealth = PLAYER_MAX_HEALTH;
            player = { x: canvas.width / 2, y: canvas.height - 50 };
            enemies = [];
            bullets = [];
            enemyBullets = [];
            powerups = [];
            explosions = [];
            lastTimestamp = performance.now();
            difficultyLevel = 1;
            gameMode = 'normal';
            nextBossThreshold = 3000;
            
            shieldActive = false;
            shieldTimer = 0;
            doubleShotActive = false;
            doubleShotTimer = 0;
            tripleShotActive = false;
            tripleShotTimer = 0;
            
            showScreen(screens.game);
            scoreDisplay.textContent = `Score: ${score}`;
            
            playMusic();
        }

        function gameOver() {
            gameRunning = false;
            mainMusic.stop();
            bossMusic.stop();
            saveHighScore();
            finalScoreDisplay.textContent = Math.floor(score);
            gameOverHighScoreDisplay.textContent = `High Score: ${highScore}`;
            showScreen(screens.gameOver);
            
            stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    opacity: Math.random() * 0.8 + 0.2
                });
            }
            parallaxStars = [];
            for (let i = 0; i < 100; i++) {
                parallaxStars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 1.5 + 0.3,
                    opacity: Math.random() * 0.5 + 0.1
                });
            }
        }
        
        function startBossFight() {
            gameMode = 'boss';
            enemies = [];
            enemyBullets = [];
            powerups = [];
            boss = new Boss();
            bossHealthContainer.style.display = 'block';
            playerHealthContainer.style.display = 'block';
            
            if (musicEnabled) {
                mainMusic.fadeOut = 2;
                mainMusic.stop("+2"); 
                playAlienSound();
                Tone.Transport.scheduleOnce(() => {
                    bossMusic.start().fadeIn = 2;
                    bossMusic.volume.value = -12;
                }, Tone.now() + 1);
            }
            
            document.body.style.setProperty('--bg-color', '#0a0a16');
            document.body.style.setProperty('--main-color', '#ff6666');
            document.body.style.setProperty('--ui-bg', 'rgba(255, 102, 102, 0.1)');
        }

        function endBossFight() {
            gameMode = 'normal';
            boss = null;
            bossHealthContainer.style.display = 'none';
            difficultyLevel++;
            nextBossThreshold += 3000;
            enemySpawnInterval = Math.max(500, 2000 - difficultyLevel * 100);
            enemyBulletSpeed = 3 + difficultyLevel * 0.2;
            baseEnemyHealth = Math.round(baseEnemyHealth * 1.1);
            
            if (musicEnabled) {
                bossMusic.fadeOut = 2;
                bossMusic.stop("+2");
                playMusic();
            }
            
            document.body.style.setProperty('--bg-color', '#0d0a1b');
            document.body.style.setProperty('--main-color', '#42e6a9');
            document.body.style.setProperty('--ui-bg', 'rgba(66, 230, 169, 0.1)');
        }

        function gameLoop(timestamp) {
            if (!gameRunning) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            scoreDisplay.textContent = `Score: ${Math.floor(score)}`;
            
            // Update power-up timers
            if (shieldActive) {
                shieldTimer -= deltaTime;
                if (shieldTimer <= 0) shieldActive = false;
            }
            if (doubleShotActive) {
                doubleShotTimer -= deltaTime;
                if (doubleShotTimer <= 0) doubleShotActive = false;
            }
            if (tripleShotActive) {
                tripleShotTimer -= deltaTime;
                if (tripleShotTimer <= 0) tripleShotActive = false;
            }
            
            // Continuous firing with rate limit
            if (isFiring && (performance.now() - lastFireTime > fireRate)) {
                fireBullet();
                lastFireTime = performance.now();
            }
            
            // Player movement
            player.x += keyboardMovement.x * 5;
            player.y += keyboardMovement.y * 5;
            
            // Clamp player position to stay within canvas bounds
            const playerWidth = playerSize * 2;
            const playerHeight = playerSize * 2;
            player.x = Math.max(playerWidth / 2, Math.min(canvas.width - playerWidth / 2, player.x));
            player.y = Math.max(playerHeight / 2, Math.min(canvas.height - playerHeight / 2, player.y));
            
            // Update stars for parallax effect (they move down to simulate forward travel)
            parallaxStars.forEach(star => {
                star.y += (gameSpeed / 400) * deltaTime;
                if (gameMode === 'boss' || score > nextBossThreshold - 500) {
                     star.y += 2;
                }
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
            stars.forEach(star => {
                star.y += (gameSpeed / 200) * deltaTime;
                if (gameMode === 'boss' || score > nextBossThreshold - 500) {
                     star.y += 4;
                }
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
            
            // Game mode logic
            if (gameMode === 'normal') {
                score += deltaTime / 100;
                
                if (score >= nextBossThreshold) {
                    startBossFight();
                }

                if (lastTimestamp - lastEnemySpawnTime > enemySpawnInterval) {
                    spawnEnemy();
                    lastEnemySpawnTime = lastTimestamp;
                }

                enemies.forEach(enemy => {
                    // Update based on movement pattern
                    if (enemy.movementPattern === 'static') {
                        const fixedY = 150;
                        if (enemy.y < fixedY) {
                            enemy.y += 3;
                        } else {
                            enemy.y = fixedY;
                            if (Math.random() < 0.005 + difficultyLevel * 0.001) {
                                spawnEnemyBullet(enemy);
                            }
                        }
                    } else if (enemy.movementPattern === 'horizontal_patrol') {
                        if (enemy.y < 150) {
                            enemy.y += 3;
                        } else {
                            enemy.y = 150;
                            enemy.x += enemy.movementDirection * 1;
                            if (enemy.x > canvas.width - 50 || enemy.x < 50) {
                                enemy.movementDirection *= -1;
                            }
                            if (Math.random() < 0.005 + difficultyLevel * 0.001) {
                                spawnEnemyBullet(enemy);
                            }
                        }
                    }
                });
                
            } else if (gameMode === 'boss') {
                boss.update();
                bossHealthBar.style.width = `${(boss.health / boss.maxHealth) * 100}%`;
            }

            if (lastTimestamp - lastPowerupSpawnTime > powerupSpawnInterval) {
                spawnPowerup();
                lastPowerupSpawnTime = lastTimestamp;
            }

            // Update objects individually
            bullets.forEach(bullet => {
                bullet.y -= 5;
            });
            bullets = bullets.filter(bullet => bullet.y > -10);
            
            enemyBullets.forEach(bullet => {
                if (bullet.isHoming) {
                    const homingFactor = 0.02 + difficultyLevel * 0.01;
                    const angle = Math.atan2(player.y - bullet.y, player.x - bullet.x);
                    bullet.speedX += homingFactor * Math.cos(angle);
                    bullet.speedY += homingFactor * Math.sin(angle);
                }
                bullet.y += bullet.speedY;
                bullet.x += bullet.speedX;
            });
            enemyBullets = enemyBullets.filter(bullet => bullet.y < canvas.height + 10);

            powerups.forEach(powerup => {
                powerup.y += 3;
            });
            powerups = powerups.filter(powerup => powerup.y < canvas.height + 50);

            // Update explosions
            explosions.forEach(explosion => {
                explosion.radius += 1;
                explosion.alpha -= 0.02;
            });
            explosions = explosions.filter(explosion => explosion.alpha > 0);

            checkCollisions();
        }

        function draw() {
            const bossProximity = Math.max(0, (score - (nextBossThreshold - 500)) / 500);
            
            const r = 13 - (13 - 10) * bossProximity;
            const g = 10 - (10 - 7) * bossProximity;
            const b = 27 - (27 - 15) * bossProximity;
            canvas.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawParallaxStars();
            drawStars();

            drawPlayer();

            if (gameMode === 'normal') {
                 enemies.forEach(enemy => drawEnemy(enemy));
            } else if (gameMode === 'boss') {
                boss.draw();
            }
            
            bullets.forEach(bullet => drawBullet(bullet));

            enemyBullets.forEach(bullet => drawEnemyBullet(bullet));

            powerups.forEach(powerup => drawPowerup(powerup));

            explosions.forEach(explosion => drawExplosion(explosion));

            if (shieldActive) {
                drawShield();
            }
            
            drawPowerupHUD();
            drawPlayerHealthBar();
        }

        function drawExplosion(explosion) {
            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 200, 0, ${explosion.alpha})`;
            ctx.fill();
        }

        function drawPlayerHealthBar() {
            playerHealthBar.style.width = `${(playerHealth / PLAYER_MAX_HEALTH) * 100}%`;
        }
        
        function drawParallaxStars() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            parallaxStars.forEach(star => {
                ctx.globalAlpha = star.opacity;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function drawStars() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            stars.forEach(star => {
                ctx.globalAlpha = star.opacity;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function drawPlayer() {
            const size = playerSize;
            ctx.shadowBlur = 20;
            ctx.shadowColor = playerColor;
            ctx.fillStyle = playerColor;
            
            ctx.fillRect(player.x - size, player.y - size, size * 2, size * 2);

            ctx.beginPath();
            ctx.moveTo(player.x - size, player.y + size);
            ctx.lineTo(player.x - size * 2, player.y + size);
            ctx.lineTo(player.x - size, player.y);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(player.x + size, player.y + size);
            ctx.lineTo(player.x + size * 2, player.y + size);
            ctx.lineTo(player.x + size, player.y);
            ctx.closePath();
            ctx.fill();

            const flameHeight = Math.sin(Date.now() / 150) * 10 + 20;
            ctx.beginPath();
            ctx.moveTo(player.x - size / 2, player.y + size * 2);
            ctx.lineTo(player.x + size / 2, player.y + size * 2);
            ctx.lineTo(player.x, player.y + size * 2 + flameHeight);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 100, 0, 0.8)';
            ctx.shadowColor = 'rgba(255, 100, 0, 1)';
            ctx.fill();
            
            ctx.shadowBlur = 0;
        }
        
        function drawShield() {
            const shieldRadius = playerSize * 3.5;
            ctx.beginPath();
            ctx.arc(player.x, player.y + playerSize, shieldRadius, 0, 2 * Math.PI);
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#66ccff';
            ctx.strokeStyle = '#66ccff';
            ctx.lineWidth = 5;
            ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.lineWidth = 1;
        }
        
        function drawPowerupHUD() {
            const hudX = 20;
            const hudY = canvas.height - 50;
            const iconSize = 30;
            const textOffset = 40;

            ctx.font = '16px Orbitron';
            ctx.textAlign = 'left';
            
            if (shieldActive) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#66ccff';
                ctx.fillStyle = '#66ccff';
                ctx.beginPath();
                ctx.arc(hudX, hudY, iconSize / 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#66ccff';
                ctx.fillText(`Shield: ${Math.ceil(shieldTimer / 1000)}s`, hudX + textOffset, hudY);
            }
            
            if (doubleShotActive) {
                const doubleShotX = shieldActive ? hudX + 150 : hudX;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#e642e6';
                ctx.fillStyle = '#e642e6';
                ctx.beginPath();
                ctx.moveTo(doubleShotX - iconSize/2, hudY - iconSize/2);
                ctx.lineTo(doubleShotX + iconSize/2, hudY - iconSize/2);
                ctx.lineTo(doubleShotX, hudY + iconSize/2);
                ctx.closePath();
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.fillStyle = '#e642e6';
                ctx.fillText(`Double Shot: ${Math.ceil(doubleShotTimer / 1000)}s`, doubleShotX + textOffset, hudY);
            }

            if (tripleShotActive) {
                const tripleShotX = (shieldActive && doubleShotActive) ? hudX + 300 : (shieldActive || doubleShotActive) ? hudX + 150 : hudX;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff8c00';
                ctx.fillStyle = '#ff8c00';
                ctx.beginPath();
                ctx.moveTo(tripleShotX - iconSize/2, hudY + iconSize/2);
                ctx.lineTo(tripleShotX + iconSize/2, hudY + iconSize/2);
                ctx.lineTo(tripleShotX, hudY - iconSize/2);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(tripleShotX, hudY, iconSize / 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ff8c00';
                ctx.fillText(`Triple Shot: ${Math.ceil(tripleShotTimer / 1000)}s`, tripleShotX + textOffset, hudY);
            }
        }
        
        function fireBullet() {
            if (sfxEnabled) {
                fireSynth.triggerAttackRelease("C4", "16n", Tone.now());
            }
            if (tripleShotActive) {
                bullets.push({ x: player.x, y: player.y, size: 5, color: '#ff8c00' });
                bullets.push({ x: player.x - 15, y: player.y, size: 5, color: '#ff8c00' });
                bullets.push({ x: player.x + 15, y: player.y, size: 5, color: '#ff8c00' });
            } else if (doubleShotActive) {
                bullets.push({ x: player.x - 10, y: player.y, size: 5, color: '#e642e6' });
                bullets.push({ x: player.x + 10, y: player.y, size: 5, color: '#e642e6' });
            } else {
                bullets.push({ x: player.x, y: player.y, size: 5, color: 'white' });
            }
        }
        
        function spawnPowerup() {
            const powerupX = Math.random() * (canvas.width - 50) + 25;
            const powerupY = -50;
            const powerupType = ['shield', 'double_shot', 'health_pack', 'triple_shot'][Math.floor(Math.random() * 4)];
            powerups.push({ x: powerupX, y: powerupY, size: 20, type: powerupType });
        }

        function spawnEnemyBullet(enemy) {
            // New logic: check if the enemy is not currently firing.
            if (!enemy.isFiring) {
                 playEnemyFireSound();
                 enemyBullets.push({
                    x: enemy.x,
                    y: enemy.y,
                    size: 5,
                    speedY: enemyBulletSpeed,
                    speedX: 0
                });
                enemy.isFiring = true;
                setTimeout(() => {
                    enemy.isFiring = false;
                }, 200); // 200ms cooldown for this specific enemy
            }
        }
        
        function spawnEnemy() {
            const x = Math.random() * (canvas.width - 100) + 50;
            const y = -50;
            const enemyType = Math.floor(Math.random() * 4);
            const movementPattern = Math.random() > 0.5 ? 'static' : 'horizontal_patrol';
            const attackPattern = Math.floor(Math.random() * 3);
            const health = baseEnemyHealth;
            enemies.push({ x, y, size: 25, type: enemyType, movementPattern, attackPattern, health, movementDirection: 1, isFiring: false });
        }
        
        function drawEnemy(enemy) {
            ctx.shadowBlur = 10;
            
            // Draw main body
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.moveTo(enemy.x, enemy.y - 15);
            ctx.lineTo(enemy.x - 25, enemy.y + 10);
            ctx.lineTo(enemy.x, enemy.y + 25);
            ctx.lineTo(enemy.x + 25, enemy.y + 10);
            ctx.closePath();
            ctx.fill();

            // Cockpit
            ctx.fillStyle = '#42e6a9';
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, 8, 0, Math.PI * 2);
            ctx.fill();

            // Pilot
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Left wing weapon
            ctx.fillStyle = '#e642e6';
            ctx.fillRect(enemy.x - 30, enemy.y + 10, 5, 10);
            
            // Right wing weapon
            ctx.fillRect(enemy.x + 25, enemy.y + 10, 5, 10);

            ctx.shadowBlur = 0;
        }
        
        function drawBullet(bullet) {
            ctx.shadowBlur = 10;
            ctx.shadowColor = bullet.color;
            ctx.fillStyle = bullet.color;
            ctx.fillRect(bullet.x, bullet.y, bullet.size, bullet.size * 2);
            ctx.shadowBlur = 0;
        }

        function drawEnemyBullet(bullet) {
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff6666';
            ctx.fillStyle = '#ff6666';
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        function drawPowerup(powerup) {
            const size = powerup.size;
            ctx.shadowBlur = 20;
            ctx.shadowColor = powerup.type === 'shield' ? '#66ccff' : powerup.type === 'double_shot' ? '#e642e6' : powerup.type === 'triple_shot' ? '#ff8c00' : '#ff0000';
            ctx.fillStyle = powerup.type === 'shield' ? '#66ccff' : powerup.type === 'double_shot' ? '#e642e6' : powerup.type === 'triple_shot' ? '#ff8c00' : '#ff0000';

            if (powerup.type === 'shield') {
                ctx.beginPath();
                ctx.arc(powerup.x, powerup.y, size / 2, 0, 2 * Math.PI);
                ctx.fill();
            } else if (powerup.type === 'double_shot') {
                ctx.beginPath();
                ctx.moveTo(powerup.x - size / 2, powerup.y + size / 2);
                ctx.lineTo(powerup.x + size / 2, powerup.y + size / 2);
                ctx.lineTo(powerup.x, powerup.y - size / 2);
                ctx.closePath();
                ctx.fill();
            } else if (powerup.type === 'triple_shot') {
                ctx.beginPath();
                ctx.moveTo(powerup.x, powerup.y - size / 2);
                ctx.lineTo(powerup.x - size/2, powerup.y + size/2);
                ctx.lineTo(powerup.x + size/2, powerup.y + size/2);
                ctx.closePath();
                ctx.fill();
            } else if (powerup.type === 'health_pack') {
                ctx.lineWidth = 5;
                ctx.strokeStyle = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(powerup.x - size/2, powerup.y);
                ctx.lineTo(powerup.x + size/2, powerup.y);
                ctx.moveTo(powerup.x, powerup.y - size/2);
                ctx.lineTo(powerup.x, powerup.y + size/2);
                ctx.stroke();
                ctx.lineWidth = 1;
            }

            ctx.shadowBlur = 0;
        }

        function checkCollisions() {
            const playerRect = { x: player.x - playerSize, y: player.y - playerSize, width: playerSize * 2, height: playerSize * 2 };
            
            // Bullet-enemy collision
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                const bulletRect = { x: bullet.x, y: bullet.y, width: bullet.size, height: bullet.size * 2 };
                
                if (gameMode === 'normal') {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        const enemyRect = { x: enemy.x - enemy.size, y: enemy.y - enemy.size, width: enemy.size * 2, height: enemy.size * 2 };
                        
                        if (isColliding(bulletRect, enemyRect)) {
                            bullets.splice(i, 1);
                            enemy.health--;
                            
                            if (enemy.health <= 0) {
                                playEnemyExplosionSound();
                                explosions.push({ x: enemy.x, y: enemy.y, radius: 0, alpha: 1 });
                                enemies.splice(j, 1);
                                score += 100;
                            }
                            break;
                        }
                    }
                } else if (gameMode === 'boss') {
                    const bossRect = { x: boss.x - boss.size, y: boss.y - boss.size, width: boss.size * 2, height: boss.size * 2 };
                    if (isColliding(bulletRect, bossRect)) {
                        bullets.splice(i, 1);
                        boss.health--;
                        if (boss.health <= 0) {
                             playEnemyExplosionSound();
                             explosions.push({ x: boss.x, y: boss.y, radius: 0, alpha: 1 });
                             endBossFight();
                        }
                        break;
                    }
                }
            }

            // Enemy bullet-player collision
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                const bulletRect = { x: bullet.x - bullet.size, y: bullet.y - bullet.size, width: bullet.size * 2, height: bullet.size * 2 };
                if (isColliding(playerRect, bulletRect)) {
                    if (shieldActive) {
                        playShieldSound();
                        enemyBullets.splice(i, 1);
                    } else {
                        playerHealth--;
                        playerHealthBar.style.width = `${(playerHealth / PLAYER_MAX_HEALTH) * 100}%`;
                        if (playerHealth <= 0) {
                            playPlayerExplosionSound();
                            gameOver();
                        } else {
                            enemyBullets.splice(i, 1);
                        }
                    }
                }
            }
            
            // Player-enemy collision
            if (gameMode === 'normal') {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const enemyRect = { x: enemy.x - enemy.size, y: enemy.y - enemy.size, width: enemy.size * 2, height: enemy.size * 2 };
                    if (isColliding(playerRect, enemyRect)) {
                        if (shieldActive) {
                            enemies.splice(i, 1);
                        } else {
                            playerHealth--;
                            if (playerHealth <= 0) {
                                playPlayerExplosionSound();
                                gameOver();
                                return;
                            } else {
                                enemies.splice(i, 1);
                            }
                        }
                    }
                }
            }

            // Power-up collision
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                const powerupRect = { x: powerup.x - powerup.size / 2, y: powerup.y - powerup.size / 2, width: powerup.size, height: powerup.size };
                if (isColliding(playerRect, powerupRect)) {
                    if (powerup.type === 'shield') {
                        shieldActive = true;
                        shieldTimer = SHIELD_DURATION;
                        playShieldSound();
                    } else if (powerup.type === 'double_shot') {
                        doubleShotActive = true;
                        doubleShotTimer = DOUBLE_SHOT_DURATION;
                        playShieldSound();
                    } else if (powerup.type === 'triple_shot') {
                        tripleShotActive = true;
                        tripleShotTimer = TRIPLE_SHOT_DURATION;
                        playTripleShotSound();
                    } else if (powerup.type === 'health_pack') {
                        if (playerHealth < PLAYER_MAX_HEALTH) {
                            playerHealth++;
                            playShieldSound();
                        }
                    }
                    powerups.splice(i, 1);
                }
            }
        }

        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        function distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }
        
        init();
    </script>
</body>
</html>
